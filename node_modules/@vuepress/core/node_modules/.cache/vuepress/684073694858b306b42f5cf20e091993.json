{"remainingRequest":"/Users/liheng/Documents/workspace/vuepress-element-extend/node_modules/vue-loader/lib/index.js??vue-loader-options!/Users/liheng/Documents/workspace/vuepress-element-extend/docs/.vuepress/components/BarChart.vue?vue&type=script&lang=js&","dependencies":[{"path":"/Users/liheng/Documents/workspace/vuepress-element-extend/docs/.vuepress/components/BarChart.vue","mtime":1598335556138},{"path":"/Users/liheng/Documents/workspace/vuepress-element-extend/node_modules/cache-loader/dist/cjs.js","mtime":499162500000},{"path":"/Users/liheng/Documents/workspace/vuepress-element-extend/node_modules/vue-loader/lib/index.js","mtime":499162500000}],"contextDependencies":[],"result":[{"type":"Buffer","data":"base64:Ly8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KCmltcG9ydCBlY2hhcnRzIGZyb20gJ2VjaGFydHMnCmV4cG9ydCBkZWZhdWx0IHsKICBuYW1lOiAnQmFyQ2hhcnQnLAogIHByb3BzOiB7CiAgICBvcHRpb25zOiB7CiAgICAgIHR5cGU6IE9iamVjdCwKICAgICAgZGVmYXVsdCgpIHsKICAgICAgICByZXR1cm4ge30KICAgICAgfQogICAgfQogIH0sCiAgZGF0YSgpIHsKICAgIHJldHVybiB7CiAgICAgIHBvbGFyOiB7fSwKICAgICAgdGl0bGU6ICcnLAogICAgICB0ZXh0Q29sb3I6ICcjMzMzJywKICAgICAgYmFzZUNvbG9yOiBbCiAgICAgICAgJyMyZThhMDAnLAogICAgICAgICcjMDA3ZmZmJywKICAgICAgICAnI2ZlOTBiZicsCiAgICAgICAgJyMxMWZlZWYnLAogICAgICAgICcjZmYzODkwJywKICAgICAgICAnI2ZmNjQ0YicsCiAgICAgICAgJyMyOWMzNDInLAogICAgICAgICcjZmY5NjAwJywKICAgICAgICAnI2EzNGJlMCcsCiAgICAgICAgJyMxMWIwZmYnCiAgICAgIF0sCiAgICAgIGJhc2VDb2xvcnM6IFsKICAgICAgICBbJyM0Y2MzZmYnLCAnIzAwYWFmZiddLAogICAgICAgIFsnI2QwNzVlYicsICcjYmMxNWZhJ10sCiAgICAgICAgWycjZjhjZjVjJywgJyNmZGJhMDAnXSwKICAgICAgICBbJyM4MGZmOTQnLCAnIzFiYjkzNCddLAogICAgICAgIFsnI2I4YWNmZScsICcjNzU1ZmZjJ10sCiAgICAgICAgWycjZmY5ODk3JywgJyNmNjUwYTAnXSwKICAgICAgICBbJyNmZmE2MmUnLCAnI2VhNWMwZiddLAogICAgICAgIFsnIzQ5ZmVkNCcsICcjMDRjNzkyJ10sCiAgICAgICAgWycjNzc4OWY5JywgJyMyYTRmZjMnXSwKICAgICAgICBbJyNmYzU1N2MnLCAnI2ZlMjQ1NyddCiAgICAgIF0KICAgIH0KICB9LAogIHdhdGNoOiB7CiAgICBvcHRpb25zOiB7CiAgICAgIGhhbmRsZXI6ICdyZW5kZXJDaGFydCcsCiAgICAgIGRlZXA6IHRydWUKICAgIH0KICB9LAogIG1ldGhvZHM6IHsKICAgIHJlbmRlckNoYXJ0KCkgewogICAgICBjb25zdCB7IHhBeGlzLCB5QXhpcyB9ID0gdGhpcy5vcHRpb25zCiAgICAgIGlmICgheEF4aXMgfHwgIXlBeGlzIHx8ICF4QXhpcy5sZW5ndGggfHwgIXlBeGlzLmxlbmd0aCkgewogICAgICAgIHJldHVybgogICAgICB9CiAgICAgIGxldCB0aGF0ID0gdGhpcwogICAgICBjb25zdCB7CiAgICAgICAgdGV4dCA9ICcnLAogICAgICAgIGlzWm9vbSA9IHJldmVyc2UgPyB5QXhpcyAmJiB5QXhpcy5sZW5ndGggPiAxMCA6IHhBeGlzICYmIHhBeGlzLmxlbmd0aCA+IDEwLAogICAgICAgIGNvbG9yID0gdGhpcy5iYXNlQ29sb3IsCiAgICAgICAgdGV4dENvbG9yID0gdGhpcy50ZXh0Q29sb3IsCiAgICAgICAgdGV4dEZvbnRTaXplID0gMTgsCiAgICAgICAgc3VidGV4dCwKICAgICAgICBzdWJ0ZXh0Q29sb3IgPSB0aGlzLnRleHRDb2xvciwKICAgICAgICBzdWJ0ZXh0Rm9udFNpemUgPSAxMiwKICAgICAgICB0aXRsZVRvcCA9ICdhdXRvJywKICAgICAgICB0aXRsZUxlZnQgPSAnY2VudGVyJywKICAgICAgICBiYWNrZ3JvdW5kQ29sb3IgPSAndHJhbnNwYXJlbnQnLAogICAgICAgIHNob3dMZWdlbmQsCiAgICAgICAgbGVnZW5kLAogICAgICAgIGhpZGVUb29sdGlwLAogICAgICAgIGxlZ2VuZFRvcCA9IDI1LAogICAgICAgIGxlZ2VuZENvbG9yID0gdGhpcy50ZXh0Q29sb3IsCiAgICAgICAgbGVnZW5kRm9udFNpemUgPSAxMiwKICAgICAgICB0b29sdGlwVHlwZSA9ICdzaGFkb3cnLAogICAgICAgIHRvb2x0aXBGb3JtYXR0ZXIgPSBudWxsLAogICAgICAgIGhpZGVUb29sQm94LAogICAgICAgIHRvb2xib3hOYW1lID0gdGV4dCwKICAgICAgICBoaWRlSW1hZ2UsCiAgICAgICAgdG9vbGJveFJpZ2h0ID0gMjUsCiAgICAgICAgdG9vbGJveFRvcCA9IDI1LAogICAgICAgIGdyaWRMZWZ0ID0gJzMlJywKICAgICAgICBncmlkUmlnaHQgPSAnMyUnLAogICAgICAgIGdyaWRCb3R0b20gPSAnMyUnLAogICAgICAgIGdyaWRUb3AgPSAnMTUlJywKICAgICAgICBoaWRleEF4aXMsCiAgICAgICAgaGlkZXhBeGlzTGluZSwKICAgICAgICB4QXhpc0NvbG9yID0gdGhpcy50ZXh0Q29sb3IsCiAgICAgICAgaGlkZXhBeGlzVGljaywKICAgICAgICB4QXhpc1RpY2tDb2xvciA9IHRoaXMudGV4dENvbG9yLAogICAgICAgIHhBeGlzVGlja1R5cGUgPSAnc29saWQnLAogICAgICAgIHhBeGlzTGFiZWxDb2xvciA9IHRoaXMudGV4dENvbG9yLAogICAgICAgIHhBeGlzRm9udFNpemUgPSAxMiwKICAgICAgICB4QXhpc0xhYmVsSW50ZXJ2YWwgPSAwLAogICAgICAgIHhBeGlzTGFiZWxSb3RhdGUgPSAwLAogICAgICAgIHhBeGlzTWF4TGVuZ3RoID0gOCwKICAgICAgICBtaW5SYW5nZSA9IG51bGwsCiAgICAgICAgbWF4UmFuZ2UgPSBudWxsLAogICAgICAgIHlBeGlzU3BsaXROdW1iZXIgPSA1LAogICAgICAgIGhpZGV5QXhpcywKICAgICAgICBoaWRleUF4aXNMaW5lLAogICAgICAgIHlBeGlzQ29sb3IgPSB0aGlzLnRleHRDb2xvciwKICAgICAgICBoaWRleUF4aXNUaWNrLAogICAgICAgIHlBeGlzVGlja0NvbG9yID0gdGhpcy50ZXh0Q29sb3IsCiAgICAgICAgeUF4aXNUaWNrVHlwZSA9ICdzb2xpZCcsCiAgICAgICAgeUF4aXNMYWJlbENvbG9yID0gdGhpcy50ZXh0Q29sb3IsCiAgICAgICAgeUF4aXNGb250U2l6ZSA9IDEyLAogICAgICAgIHlBeGlzU3BsaXRMaW5lQ29sb3IgPSB0aGlzLnRleHRDb2xvciwKICAgICAgICB5QXhpc1NwbGl0TGluZVR5cGUgPSAnc29saWQnLAogICAgICAgIGlzU3RhY2ssCiAgICAgICAgc2hvd0xhYmVsLAogICAgICAgIGxhYmVsUG9zaXRpb24gPSAndG9wJywKICAgICAgICBsYWJlbENvbG9yID0gdGhpcy50ZXh0Q29sb3IsCiAgICAgICAgbGFiZWxGb250U2l6ZSA9IDEyLAogICAgICAgIGlzR3JhZGllbnQsCiAgICAgICAgcmV2ZXJzZSwKICAgICAgICBpZAogICAgICB9ID0gdGhpcy5vcHRpb25zCiAgICAgIHRoaXMudGl0bGUgPSB0ZXh0IHx8IHRvb2xib3hOYW1lCiAgICAgIHRoaXMucG9sYXIgPSB7CiAgICAgICAgY29sb3IsCiAgICAgICAgLy8g5qCH6aKYCiAgICAgICAgdGl0bGU6IHsKICAgICAgICAgIHRleHQsCiAgICAgICAgICB0ZXh0U3R5bGU6IHsKICAgICAgICAgICAgY29sb3I6IHRleHRDb2xvciwKICAgICAgICAgICAgZm9udFNpemU6IHRleHRGb250U2l6ZQogICAgICAgICAgfSwKICAgICAgICAgIHN1YnRleHQ6IHN1YnRleHQgfHwgKGlzWm9vbSA/ICflvZPliY3mlbDmja7ovoPlpJrvvIzor7fmu5rliqjpvKDmoIfmiJbnvKnmlL7lsY/luZXmn6XnnIvlrozmlbTmlbDmja4nIDogJycpLAogICAgICAgICAgc3VidGV4dFN0eWxlOiB7CiAgICAgICAgICAgIGNvbG9yOiBzdWJ0ZXh0Q29sb3IsCiAgICAgICAgICAgIGZvbnRTaXplOiBzdWJ0ZXh0Rm9udFNpemUKICAgICAgICAgIH0sCiAgICAgICAgICB0b3A6IHRpdGxlVG9wLAogICAgICAgICAgbGVmdDogdGl0bGVMZWZ0LAogICAgICAgICAgYmFja2dyb3VuZENvbG9yCiAgICAgICAgfSwKICAgICAgICAvLyDlm77kvosKICAgICAgICBsZWdlbmQ6IHsKICAgICAgICAgIHR5cGU6ICdzY3JvbGwnLCAvLyDlj6rmnInlrrnlmajmlL7kuI3kuIvlm77kvossIHNjcm9sbCDmiY3kvJrnlJ/mlYgKICAgICAgICAgIHNob3c6IHRoaXMuJHV0aWxzLmNoZWNrUGFyYW0oc2hvd0xlZ2VuZCwgbGVnZW5kICYmIGxlZ2VuZC5sZW5ndGggPiAxKSwKICAgICAgICAgIGRhdGE6IGxlZ2VuZCB8fCBbdGV4dF0sCiAgICAgICAgICByaWdodDogIWhpZGVUb29sdGlwID8gNjAgOiAwLAogICAgICAgICAgdG9wOiBsZWdlbmRUb3AsCiAgICAgICAgICB0ZXh0U3R5bGU6IHsKICAgICAgICAgICAgY29sb3I6IGxlZ2VuZENvbG9yLAogICAgICAgICAgICBmb250U2l6ZTogbGVnZW5kRm9udFNpemUKICAgICAgICAgIH0KICAgICAgICB9LAogICAgICAgIC8vIOaPkOekuuahhgogICAgICAgIHRvb2x0aXA6IHsKICAgICAgICAgIHNob3c6ICFoaWRlVG9vbHRpcCwKICAgICAgICAgIHRyaWdnZXI6ICdheGlzJywKICAgICAgICAgIGF4aXNQb2ludGVyOiB7CiAgICAgICAgICAgIC8vIOWdkOagh+i9tOaMh+ekuuWZqO+8jOWdkOagh+i9tOinpuWPkeacieaViAogICAgICAgICAgICB0eXBlOiB0b29sdGlwVHlwZSAvLyDpu5jorqTkuLrnm7Tnur/vvIzlj6/pgInkuLrvvJonbGluZScgfCAnc2hhZG93JwogICAgICAgICAgfSwKICAgICAgICAgIGZvcm1hdHRlcjogdG9vbHRpcEZvcm1hdHRlcgogICAgICAgIH0sCiAgICAgICAgLy8g5bel5YW35qCPCiAgICAgICAgdG9vbGJveDogewogICAgICAgICAgc2hvdzogIWhpZGVUb29sQm94LAogICAgICAgICAgZmVhdHVyZTogewogICAgICAgICAgICBzYXZlQXNJbWFnZTogewogICAgICAgICAgICAgIHNob3c6ICFoaWRlSW1hZ2UsCiAgICAgICAgICAgICAgbmFtZTogdG9vbGJveE5hbWUsCiAgICAgICAgICAgICAgYmFja2dyb3VuZENvbG9yOiAncmdiYSgwLCAzNSwgNTUsIDAuNCknCiAgICAgICAgICAgIH0KICAgICAgICAgIH0sCiAgICAgICAgICByaWdodDogdG9vbGJveFJpZ2h0LAogICAgICAgICAgdG9wOiB0b29sYm94VG9wLAogICAgICAgICAgaWNvblN0eWxlOiB7CiAgICAgICAgICAgIG5vcm1hbDogewogICAgICAgICAgICAgIGJvcmRlckNvbG9yOiB0aGlzLnRleHRDb2xvcgogICAgICAgICAgICB9CiAgICAgICAgICB9CiAgICAgICAgfSwKICAgICAgICAvLyDnm7Top5LlnZDmoIfns7vlhoXnu5jlm77nvZHmoLwKICAgICAgICBncmlkOiB7CiAgICAgICAgICBsZWZ0OiBncmlkTGVmdCwKICAgICAgICAgIHJpZ2h0OiBncmlkUmlnaHQsCiAgICAgICAgICBib3R0b206IGdyaWRCb3R0b20sCiAgICAgICAgICB0b3A6IGdyaWRUb3AsCiAgICAgICAgICBjb250YWluTGFiZWw6IHRydWUKICAgICAgICB9LAogICAgICAgIHhBeGlzOiBbCiAgICAgICAgICB7CiAgICAgICAgICAgIHR5cGU6ICdjYXRlZ29yeScsCiAgICAgICAgICAgIHNob3c6ICFoaWRleEF4aXMsCiAgICAgICAgICAgIGRhdGE6IHhBeGlzLAogICAgICAgICAgICAvLyDlnZDmoIfovbTovbTnur8KICAgICAgICAgICAgYXhpc0xpbmU6IHsKICAgICAgICAgICAgICBzaG93OiAhaGlkZXhBeGlzTGluZSwKICAgICAgICAgICAgICBsaW5lU3R5bGU6IHsKICAgICAgICAgICAgICAgIGNvbG9yOiB4QXhpc0NvbG9yCiAgICAgICAgICAgICAgfQogICAgICAgICAgICB9LAogICAgICAgICAgICAvLyDlnZDmoIfovbTliLvluqYKICAgICAgICAgICAgYXhpc1RpY2s6IHsKICAgICAgICAgICAgICBzaG93OiAhaGlkZXhBeGlzVGljaywKICAgICAgICAgICAgICBhbGlnbldpdGhMYWJlbDogdHJ1ZSwKICAgICAgICAgICAgICBsaW5lU3R5bGU6IHsKICAgICAgICAgICAgICAgIHR5cGU6IHhBeGlzVGlja1R5cGUsCiAgICAgICAgICAgICAgICBjb2xvcjogeEF4aXNUaWNrQ29sb3IKICAgICAgICAgICAgICB9CiAgICAgICAgICAgIH0sCiAgICAgICAgICAgIC8vIOWdkOagh+i9tOWIu+W6puagh+etvgogICAgICAgICAgICBheGlzTGFiZWw6IHsKICAgICAgICAgICAgICBjb2xvcjogeEF4aXNMYWJlbENvbG9yLAogICAgICAgICAgICAgIGZvbnRTaXplOiB4QXhpc0ZvbnRTaXplLAogICAgICAgICAgICAgIC8vIOWdkOagh+i9tOWIu+W6puagh+etvueahOaYvuekuumXtOmalO+8jOWcqOexu+ebrui9tOS4reacieaViOOAguWPr+S7peiuvue9ruaIkCAwIOW8uuWItuaYvuekuuaJgOacieagh+etvuOAggogICAgICAgICAgICAgIGludGVydmFsOiB4QXhpc0xhYmVsSW50ZXJ2YWwsCiAgICAgICAgICAgICAgcm90YXRlOiB4QXhpc0xhYmVsUm90YXRlLAogICAgICAgICAgICAgIGZvcm1hdHRlcih2YWx1ZSkgewogICAgICAgICAgICAgICAgLy8gbGV0IHJldCA9ICcnIC8vIOaLvOaOpeWKoFxu6L+U5Zue55qE57G755uu6aG5CiAgICAgICAgICAgICAgICAvLyB4QXhpc01heExlbmd0aCDmr4/pobnmmL7npLrmloflrZfkuKrmlbAKICAgICAgICAgICAgICAgIGxldCB2YWxMZW5ndGggPSB2YWx1ZS5sZW5ndGggLy8gWOi9tOexu+ebrumhueeahOaWh+Wtl+S4quaVsAogICAgICAgICAgICAgICAgbGV0IHJvd04gPSBNYXRoLmNlaWwodmFsTGVuZ3RoIC8geEF4aXNNYXhMZW5ndGgpIC8vIOexu+ebrumhuemcgOimgeaNouihjOeahOihjOaVsAogICAgICAgICAgICAgICAgaWYgKHJvd04gPiAxKSB7CiAgICAgICAgICAgICAgICAgIC8vIOWmguaenOexu+ebrumhueeahOaWh+Wtl+Wkp+S6jiB4QXhpc01heExlbmd0aCwKICAgICAgICAgICAgICAgICAgLy8gZm9yIChsZXQgaSA9IDA7IGkgPCByb3dOOyBpKyspIHsKICAgICAgICAgICAgICAgICAgLy8gICBsZXQgdGVtcCA9ICcnIC8vIOavj+asoeaIquWPlueahOWtl+espuS4sgogICAgICAgICAgICAgICAgICAvLyAgIGxldCBzdGFydCA9IGkgKiB4QXhpc01heExlbmd0aCAvLyDlvIDlp4vmiKrlj5bnmoTkvY3nva4KICAgICAgICAgICAgICAgICAgLy8gICBsZXQgZW5kID0gc3RhcnQgKyB4QXhpc01heExlbmd0aCAvLyDnu5PmnZ/miKrlj5bnmoTkvY3nva4KICAgICAgICAgICAgICAgICAgLy8gICAvLyDov5nph4zliqDkuIDkuKrmmK/lkKbmmK/mnIDlkI7kuIDooYznmoTliKTmlq0KICAgICAgICAgICAgICAgICAgLy8gICB0ZW1wID0gdmFsdWUuc3Vic3RyaW5nKHN0YXJ0LCBlbmQpICsgKGkgPT09IHJvd04gLSAxID8gJycgOiAnXG4nKQogICAgICAgICAgICAgICAgICAvLyAgIHJldCArPSB0ZW1wIC8vIOaLvOaOpeacgOe7iOeahOWtl+espuS4sgogICAgICAgICAgICAgICAgICAvLyB9CiAgICAgICAgICAgICAgICAgIC8vIHJldHVybiByZXQKICAgICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlLnN1YnN0cmluZygwLCB4QXhpc01heExlbmd0aCkgKyAn4oCmJwogICAgICAgICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlCiAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgfQogICAgICAgICAgICB9CiAgICAgICAgICB9CiAgICAgICAgXSwKICAgICAgICB5QXhpczogWwogICAgICAgICAgewogICAgICAgICAgICB0eXBlOiAndmFsdWUnLAogICAgICAgICAgICBtaW46IG1pblJhbmdlLAogICAgICAgICAgICBtYXg6IG1heFJhbmdlLAogICAgICAgICAgICBzcGxpdE51bWJlcjogeUF4aXNTcGxpdE51bWJlciwKICAgICAgICAgICAgc2hvdzogIWhpZGV5QXhpcywKICAgICAgICAgICAgYXhpc0xpbmU6IHsKICAgICAgICAgICAgICBzaG93OiAhaGlkZXlBeGlzTGluZSwKICAgICAgICAgICAgICBsaW5lU3R5bGU6IHsKICAgICAgICAgICAgICAgIGNvbG9yOiB5QXhpc0NvbG9yCiAgICAgICAgICAgICAgfQogICAgICAgICAgICB9LAogICAgICAgICAgICAvLyDlnZDmoIfovbTliLvluqYKICAgICAgICAgICAgYXhpc1RpY2s6IHsKICAgICAgICAgICAgICBzaG93OiAhaGlkZXlBeGlzVGljaywKICAgICAgICAgICAgICBhbGlnbldpdGhMYWJlbDogdHJ1ZSwKICAgICAgICAgICAgICBsaW5lU3R5bGU6IHsKICAgICAgICAgICAgICAgIHR5cGU6IHlBeGlzVGlja1R5cGUsCiAgICAgICAgICAgICAgICBjb2xvcjogeUF4aXNUaWNrQ29sb3IKICAgICAgICAgICAgICB9CiAgICAgICAgICAgIH0sCiAgICAgICAgICAgIC8vIOWdkOagh+i9tOWIu+W6puagh+etvgogICAgICAgICAgICBheGlzTGFiZWw6IHsKICAgICAgICAgICAgICBjb2xvcjogeUF4aXNMYWJlbENvbG9yLAogICAgICAgICAgICAgIGZvbnRTaXplOiB5QXhpc0ZvbnRTaXplCiAgICAgICAgICAgIH0sCiAgICAgICAgICAgIHNwbGl0TGluZTogewogICAgICAgICAgICAgIGxpbmVTdHlsZTogewogICAgICAgICAgICAgICAgdHlwZTogeUF4aXNTcGxpdExpbmVUeXBlLAogICAgICAgICAgICAgICAgY29sb3I6IHlBeGlzU3BsaXRMaW5lQ29sb3IKICAgICAgICAgICAgICB9CiAgICAgICAgICAgIH0KICAgICAgICAgIH0KICAgICAgICBdCiAgICAgIH0KICAgICAgLy8g5aSa5L6LCiAgICAgIGlmIChsZWdlbmQgJiYgbGVnZW5kLmxlbmd0aCA+IDEpIHsKICAgICAgICB0aGlzLnBvbGFyLnNlcmllcyA9IGxlZ2VuZC5tYXAoKGl0ZW0sIGluZGV4KSA9PiAoewogICAgICAgICAgbmFtZTogaXRlbSwKICAgICAgICAgIHR5cGU6ICdiYXInLAogICAgICAgICAgLi4uKGlzU3RhY2sgJiYgeyBzdGFjazogJ+aAu+mHjycgfSksCiAgICAgICAgICBiYXJNYXhXaWR0aDogMjUsCiAgICAgICAgICBkYXRhOiB5QXhpc1tpbmRleF0sCiAgICAgICAgICBsYWJlbDogewogICAgICAgICAgICBzaG93OiBzaG93TGFiZWwsCiAgICAgICAgICAgIHBvc2l0aW9uOiBsYWJlbFBvc2l0aW9uLAogICAgICAgICAgICBjb2xvcjogbGFiZWxDb2xvciwKICAgICAgICAgICAgZm9udFNpemU6IGxhYmVsRm9udFNpemUKICAgICAgICAgIH0KICAgICAgICB9KSkKICAgICAgICAvLyDljZXkvosKICAgICAgfSBlbHNlIHsKICAgICAgICBsZXQgY29sb3IwID0gJycKICAgICAgICBsZXQgY29sb3IxID0gJycKICAgICAgICAvLyDmmK/lkKbmuJDlj5gKICAgICAgICBpZiAoaXNHcmFkaWVudCkgewogICAgICAgICAgaWYgKGNvbG9yICYmIGNvbG9yWzBdICYmIGNvbG9yWzFdKSB7CiAgICAgICAgICAgIGNvbG9yMCA9IGNvbG9yWzBdCiAgICAgICAgICAgIGNvbG9yMSA9IGNvbG9yWzFdCiAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICBjb2xvcjAgPSB0aGlzLmJhc2VDb2xvcnNbMF1bMF0KICAgICAgICAgICAgY29sb3IxID0gdGhpcy5iYXNlQ29sb3JzWzBdWzFdCiAgICAgICAgICB9CiAgICAgICAgfSBlbHNlIHsKICAgICAgICAgIGlmIChjb2xvciAmJiBjb2xvclswXSkgewogICAgICAgICAgICBjb2xvcjAgPSBjb2xvclswXQogICAgICAgICAgICBjb2xvcjEgPSBjb2xvclswXQogICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgY29sb3IwID0gdGhpcy5iYXNlQ29sb3JbMF0KICAgICAgICAgICAgY29sb3IxID0gdGhpcy5iYXNlQ29sb3JbMF0KICAgICAgICAgIH0KICAgICAgICB9CiAgICAgICAgdGhpcy5wb2xhci5zZXJpZXMgPSBbCiAgICAgICAgICB7CiAgICAgICAgICAgIG5hbWU6IGxlZ2VuZCA/IGxlZ2VuZFswXSA6IHRleHQsCiAgICAgICAgICAgIHR5cGU6ICdiYXInLAogICAgICAgICAgICBiYXJNYXhXaWR0aDogMjUsCiAgICAgICAgICAgIGRhdGE6IHlBeGlzLAogICAgICAgICAgICBsYWJlbDogewogICAgICAgICAgICAgIHNob3c6IHNob3dMYWJlbCwKICAgICAgICAgICAgICBwb3NpdGlvbjogbGFiZWxQb3NpdGlvbiwKICAgICAgICAgICAgICBjb2xvcjogbGFiZWxDb2xvciwKICAgICAgICAgICAgICBmb250U2l6ZTogbGFiZWxGb250U2l6ZQogICAgICAgICAgICB9LAogICAgICAgICAgICBpdGVtU3R5bGU6IHsKICAgICAgICAgICAgICAvLyDmuJDlj5gKICAgICAgICAgICAgICBub3JtYWw6IHsKICAgICAgICAgICAgICAgIGNvbG9yOiBuZXcgZWNoYXJ0cy5ncmFwaGljLkxpbmVhckdyYWRpZW50KDAsIDEsIDAsIDAsIFsKICAgICAgICAgICAgICAgICAgewogICAgICAgICAgICAgICAgICAgIG9mZnNldDogMCwKICAgICAgICAgICAgICAgICAgICBjb2xvcjogY29sb3IwCiAgICAgICAgICAgICAgICAgIH0sCiAgICAgICAgICAgICAgICAgIHsKICAgICAgICAgICAgICAgICAgICBvZmZzZXQ6IDEsCiAgICAgICAgICAgICAgICAgICAgY29sb3I6IGNvbG9yMQogICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICBdKSwKICAgICAgICAgICAgICAgIGJhckJvcmRlclJhZGl1czogNAogICAgICAgICAgICAgIH0KICAgICAgICAgICAgfQogICAgICAgICAgfQogICAgICAgIF0KICAgICAgfQogICAgICAvLyDlvIDlkK/nvKnmlL4KICAgICAgaWYgKGlzWm9vbSkgewogICAgICAgIHRoaXMucG9sYXIuZGF0YVpvb20gPSBbCiAgICAgICAgICB7CiAgICAgICAgICAgIHR5cGU6ICdpbnNpZGUnLAogICAgICAgICAgICBzaG93OiB0cnVlLAogICAgICAgICAgICB4QXhpc0luZGV4OiBbMF0sCiAgICAgICAgICAgIHN0YXJ0OiAxLAogICAgICAgICAgICBlbmQ6IDM1CiAgICAgICAgICB9CiAgICAgICAgXQogICAgICB9CiAgICAgIC8vIOW8gOWQr+WPjei9rAogICAgICBpZiAocmV2ZXJzZSkgewogICAgICAgIDtbdGhpcy5wb2xhci54QXhpcywgdGhpcy5wb2xhci55QXhpc10gPSBbdGhpcy5wb2xhci55QXhpcywgdGhpcy5wb2xhci54QXhpc10KICAgICAgICB0aGlzLnBvbGFyLnlBeGlzWzBdLmRhdGEgPSBbLi4ueEF4aXNdLnJldmVyc2UoKQogICAgICAgIHRoaXMucG9sYXIuc2VyaWVzID0gWwogICAgICAgICAgewogICAgICAgICAgICBuYW1lOiBsZWdlbmQgPyBsZWdlbmRbMF0gOiB0ZXh0LAogICAgICAgICAgICB0eXBlOiAnYmFyJywKICAgICAgICAgICAgYmFyTWF4V2lkdGg6IDI1LAogICAgICAgICAgICBkYXRhOiBbLi4ueUF4aXNdLnJldmVyc2UoKSwKICAgICAgICAgICAgaWQ6IHRoaXMuJHV0aWxzLmNoZWNrUGFyYW0oaWQsIG51bGwpLAogICAgICAgICAgICBsYWJlbDogewogICAgICAgICAgICAgIHNob3c6IHNob3dMYWJlbCwKICAgICAgICAgICAgICBwb3NpdGlvbjogbGFiZWxQb3NpdGlvbiwKICAgICAgICAgICAgICBjb2xvcjogbGFiZWxDb2xvciwKICAgICAgICAgICAgICBmb250U2l6ZTogbGFiZWxGb250U2l6ZQogICAgICAgICAgICB9LAogICAgICAgICAgICBpdGVtU3R5bGU6IGlzR3JhZGllbnQKICAgICAgICAgICAgICA/IHsKICAgICAgICAgICAgICAgICAgbm9ybWFsOiB7CiAgICAgICAgICAgICAgICAgICAgY29sb3IocGFyYW1zKSB7CiAgICAgICAgICAgICAgICAgICAgICBsZXQgaW5kZXggPSBjb2xvcgogICAgICAgICAgICAgICAgICAgICAgICA/IHBhcmFtcy5kYXRhSW5kZXggJSBjb2xvci5sZW5ndGgKICAgICAgICAgICAgICAgICAgICAgICAgOiBwYXJhbXMuZGF0YUluZGV4ICUgdGhhdC5iYXNlQ29sb3JzLmxlbmd0aAogICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBlY2hhcnRzLmdyYXBoaWMuTGluZWFyR3JhZGllbnQoMSwgMCwgMCwgMCwgWwogICAgICAgICAgICAgICAgICAgICAgICB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgb2Zmc2V0OiAwLAogICAgICAgICAgICAgICAgICAgICAgICAgIGNvbG9yOiBjb2xvciA/IGNvbG9yW2luZGV4XVswXSA6IHRoYXQuYmFzZUNvbG9yc1tpbmRleF1bMF0KICAgICAgICAgICAgICAgICAgICAgICAgfSwKICAgICAgICAgICAgICAgICAgICAgICAgewogICAgICAgICAgICAgICAgICAgICAgICAgIG9mZnNldDogMSwKICAgICAgICAgICAgICAgICAgICAgICAgICBjb2xvcjogY29sb3IgPyBjb2xvcltpbmRleF1bMV0gOiB0aGF0LmJhc2VDb2xvcnNbaW5kZXhdWzFdCiAgICAgICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgICAgIF0pCiAgICAgICAgICAgICAgICAgICAgfSwKICAgICAgICAgICAgICAgICAgICBiYXJCb3JkZXJSYWRpdXM6IDQwCiAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICA6IHsKICAgICAgICAgICAgICAgICAgbm9ybWFsOiB7CiAgICAgICAgICAgICAgICAgICAgY29sb3IocGFyYW1zKSB7CiAgICAgICAgICAgICAgICAgICAgICBsZXQgaW5kZXggPSBjb2xvcgogICAgICAgICAgICAgICAgICAgICAgICA/IHBhcmFtcy5kYXRhSW5kZXggJSBjb2xvci5sZW5ndGgKICAgICAgICAgICAgICAgICAgICAgICAgOiBwYXJhbXMuZGF0YUluZGV4ICUgdGhhdC5iYXNlQ29sb3JzLmxlbmd0aAogICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBlY2hhcnRzLmdyYXBoaWMuTGluZWFyR3JhZGllbnQoMSwgMCwgMCwgMCwgWwogICAgICAgICAgICAgICAgICAgICAgICB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgb2Zmc2V0OiAwLAogICAgICAgICAgICAgICAgICAgICAgICAgIGNvbG9yOiBjb2xvciA/IGNvbG9yW2luZGV4XSA6IHRoYXQuYmFzZUNvbG9yW2luZGV4XQogICAgICAgICAgICAgICAgICAgICAgICB9LAogICAgICAgICAgICAgICAgICAgICAgICB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgb2Zmc2V0OiAxLAogICAgICAgICAgICAgICAgICAgICAgICAgIGNvbG9yOiBjb2xvciA/IGNvbG9yW2luZGV4XSA6IHRoYXQuYmFzZUNvbG9yW2luZGV4XQogICAgICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgICAgICBdKQogICAgICAgICAgICAgICAgICAgIH0sCiAgICAgICAgICAgICAgICAgICAgYmFyQm9yZGVyUmFkaXVzOiA0MAogICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICB9CiAgICAgICAgICB9CiAgICAgICAgXQogICAgICAgIC8vIOW8gOWQr+e8qeaUvgogICAgICAgIGlmIChpc1pvb20pIHsKICAgICAgICAgIHRoaXMucG9sYXIuZGF0YVpvb20gPSBbCiAgICAgICAgICAgIHsKICAgICAgICAgICAgICB0eXBlOiAnaW5zaWRlJywKICAgICAgICAgICAgICBzaG93OiB0cnVlLAogICAgICAgICAgICAgIHlBeGlzSW5kZXg6IFswXSwKICAgICAgICAgICAgICBzdGFydDogMSwKICAgICAgICAgICAgICBlbmQ6IDM1CiAgICAgICAgICAgIH0KICAgICAgICAgIF0KICAgICAgICB9CiAgICAgIH0KICAgIH0sCiAgICBoYW5kbGVCYXJDbGljayhldmVudCkgewogICAgICB0aGlzLiRlbWl0KCdpdGVtLWNsaWNrJywgZXZlbnQsIHRoaXMub3B0aW9ucy54QXhpcykKICAgIH0KICB9LAogIG1vdW50ZWQoKSB7CiAgICB0aGlzLnJlbmRlckNoYXJ0KCkKICB9Cn0K"},{"version":3,"sources":["BarChart.vue"],"names":[],"mappings":";;;;;;;;;;;;;;AAcA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"BarChart.vue","sourceRoot":"docs/.vuepress/components","sourcesContent":["<template>\n  <div class=\"echarts-container\">\n    <chart\n      ref=\"bar\"\n      :options=\"polar\"\n      auto-resize\n      v-if=\"options.xAxis && options.xAxis.length\"\n      @click=\"handleBarClick\"\n    ></chart>\n    <no-data :title=\"title\" v-else></no-data>\n  </div>\n</template>\n\n<script>\nimport echarts from 'echarts'\nexport default {\n  name: 'BarChart',\n  props: {\n    options: {\n      type: Object,\n      default() {\n        return {}\n      }\n    }\n  },\n  data() {\n    return {\n      polar: {},\n      title: '',\n      textColor: '#333',\n      baseColor: [\n        '#2e8a00',\n        '#007fff',\n        '#fe90bf',\n        '#11feef',\n        '#ff3890',\n        '#ff644b',\n        '#29c342',\n        '#ff9600',\n        '#a34be0',\n        '#11b0ff'\n      ],\n      baseColors: [\n        ['#4cc3ff', '#00aaff'],\n        ['#d075eb', '#bc15fa'],\n        ['#f8cf5c', '#fdba00'],\n        ['#80ff94', '#1bb934'],\n        ['#b8acfe', '#755ffc'],\n        ['#ff9897', '#f650a0'],\n        ['#ffa62e', '#ea5c0f'],\n        ['#49fed4', '#04c792'],\n        ['#7789f9', '#2a4ff3'],\n        ['#fc557c', '#fe2457']\n      ]\n    }\n  },\n  watch: {\n    options: {\n      handler: 'renderChart',\n      deep: true\n    }\n  },\n  methods: {\n    renderChart() {\n      const { xAxis, yAxis } = this.options\n      if (!xAxis || !yAxis || !xAxis.length || !yAxis.length) {\n        return\n      }\n      let that = this\n      const {\n        text = '',\n        isZoom = reverse ? yAxis && yAxis.length > 10 : xAxis && xAxis.length > 10,\n        color = this.baseColor,\n        textColor = this.textColor,\n        textFontSize = 18,\n        subtext,\n        subtextColor = this.textColor,\n        subtextFontSize = 12,\n        titleTop = 'auto',\n        titleLeft = 'center',\n        backgroundColor = 'transparent',\n        showLegend,\n        legend,\n        hideTooltip,\n        legendTop = 25,\n        legendColor = this.textColor,\n        legendFontSize = 12,\n        tooltipType = 'shadow',\n        tooltipFormatter = null,\n        hideToolBox,\n        toolboxName = text,\n        hideImage,\n        toolboxRight = 25,\n        toolboxTop = 25,\n        gridLeft = '3%',\n        gridRight = '3%',\n        gridBottom = '3%',\n        gridTop = '15%',\n        hidexAxis,\n        hidexAxisLine,\n        xAxisColor = this.textColor,\n        hidexAxisTick,\n        xAxisTickColor = this.textColor,\n        xAxisTickType = 'solid',\n        xAxisLabelColor = this.textColor,\n        xAxisFontSize = 12,\n        xAxisLabelInterval = 0,\n        xAxisLabelRotate = 0,\n        xAxisMaxLength = 8,\n        minRange = null,\n        maxRange = null,\n        yAxisSplitNumber = 5,\n        hideyAxis,\n        hideyAxisLine,\n        yAxisColor = this.textColor,\n        hideyAxisTick,\n        yAxisTickColor = this.textColor,\n        yAxisTickType = 'solid',\n        yAxisLabelColor = this.textColor,\n        yAxisFontSize = 12,\n        yAxisSplitLineColor = this.textColor,\n        yAxisSplitLineType = 'solid',\n        isStack,\n        showLabel,\n        labelPosition = 'top',\n        labelColor = this.textColor,\n        labelFontSize = 12,\n        isGradient,\n        reverse,\n        id\n      } = this.options\n      this.title = text || toolboxName\n      this.polar = {\n        color,\n        // 标题\n        title: {\n          text,\n          textStyle: {\n            color: textColor,\n            fontSize: textFontSize\n          },\n          subtext: subtext || (isZoom ? '当前数据较多，请滚动鼠标或缩放屏幕查看完整数据' : ''),\n          subtextStyle: {\n            color: subtextColor,\n            fontSize: subtextFontSize\n          },\n          top: titleTop,\n          left: titleLeft,\n          backgroundColor\n        },\n        // 图例\n        legend: {\n          type: 'scroll', // 只有容器放不下图例, scroll 才会生效\n          show: this.$utils.checkParam(showLegend, legend && legend.length > 1),\n          data: legend || [text],\n          right: !hideTooltip ? 60 : 0,\n          top: legendTop,\n          textStyle: {\n            color: legendColor,\n            fontSize: legendFontSize\n          }\n        },\n        // 提示框\n        tooltip: {\n          show: !hideTooltip,\n          trigger: 'axis',\n          axisPointer: {\n            // 坐标轴指示器，坐标轴触发有效\n            type: tooltipType // 默认为直线，可选为：'line' | 'shadow'\n          },\n          formatter: tooltipFormatter\n        },\n        // 工具栏\n        toolbox: {\n          show: !hideToolBox,\n          feature: {\n            saveAsImage: {\n              show: !hideImage,\n              name: toolboxName,\n              backgroundColor: 'rgba(0, 35, 55, 0.4)'\n            }\n          },\n          right: toolboxRight,\n          top: toolboxTop,\n          iconStyle: {\n            normal: {\n              borderColor: this.textColor\n            }\n          }\n        },\n        // 直角坐标系内绘图网格\n        grid: {\n          left: gridLeft,\n          right: gridRight,\n          bottom: gridBottom,\n          top: gridTop,\n          containLabel: true\n        },\n        xAxis: [\n          {\n            type: 'category',\n            show: !hidexAxis,\n            data: xAxis,\n            // 坐标轴轴线\n            axisLine: {\n              show: !hidexAxisLine,\n              lineStyle: {\n                color: xAxisColor\n              }\n            },\n            // 坐标轴刻度\n            axisTick: {\n              show: !hidexAxisTick,\n              alignWithLabel: true,\n              lineStyle: {\n                type: xAxisTickType,\n                color: xAxisTickColor\n              }\n            },\n            // 坐标轴刻度标签\n            axisLabel: {\n              color: xAxisLabelColor,\n              fontSize: xAxisFontSize,\n              // 坐标轴刻度标签的显示间隔，在类目轴中有效。可以设置成 0 强制显示所有标签。\n              interval: xAxisLabelInterval,\n              rotate: xAxisLabelRotate,\n              formatter(value) {\n                // let ret = '' // 拼接加\\n返回的类目项\n                // xAxisMaxLength 每项显示文字个数\n                let valLength = value.length // X轴类目项的文字个数\n                let rowN = Math.ceil(valLength / xAxisMaxLength) // 类目项需要换行的行数\n                if (rowN > 1) {\n                  // 如果类目项的文字大于 xAxisMaxLength,\n                  // for (let i = 0; i < rowN; i++) {\n                  //   let temp = '' // 每次截取的字符串\n                  //   let start = i * xAxisMaxLength // 开始截取的位置\n                  //   let end = start + xAxisMaxLength // 结束截取的位置\n                  //   // 这里加一个是否是最后一行的判断\n                  //   temp = value.substring(start, end) + (i === rowN - 1 ? '' : '\\n')\n                  //   ret += temp // 拼接最终的字符串\n                  // }\n                  // return ret\n                  return value.substring(0, xAxisMaxLength) + '…'\n                } else {\n                  return value\n                }\n              }\n            }\n          }\n        ],\n        yAxis: [\n          {\n            type: 'value',\n            min: minRange,\n            max: maxRange,\n            splitNumber: yAxisSplitNumber,\n            show: !hideyAxis,\n            axisLine: {\n              show: !hideyAxisLine,\n              lineStyle: {\n                color: yAxisColor\n              }\n            },\n            // 坐标轴刻度\n            axisTick: {\n              show: !hideyAxisTick,\n              alignWithLabel: true,\n              lineStyle: {\n                type: yAxisTickType,\n                color: yAxisTickColor\n              }\n            },\n            // 坐标轴刻度标签\n            axisLabel: {\n              color: yAxisLabelColor,\n              fontSize: yAxisFontSize\n            },\n            splitLine: {\n              lineStyle: {\n                type: yAxisSplitLineType,\n                color: yAxisSplitLineColor\n              }\n            }\n          }\n        ]\n      }\n      // 多例\n      if (legend && legend.length > 1) {\n        this.polar.series = legend.map((item, index) => ({\n          name: item,\n          type: 'bar',\n          ...(isStack && { stack: '总量' }),\n          barMaxWidth: 25,\n          data: yAxis[index],\n          label: {\n            show: showLabel,\n            position: labelPosition,\n            color: labelColor,\n            fontSize: labelFontSize\n          }\n        }))\n        // 单例\n      } else {\n        let color0 = ''\n        let color1 = ''\n        // 是否渐变\n        if (isGradient) {\n          if (color && color[0] && color[1]) {\n            color0 = color[0]\n            color1 = color[1]\n          } else {\n            color0 = this.baseColors[0][0]\n            color1 = this.baseColors[0][1]\n          }\n        } else {\n          if (color && color[0]) {\n            color0 = color[0]\n            color1 = color[0]\n          } else {\n            color0 = this.baseColor[0]\n            color1 = this.baseColor[0]\n          }\n        }\n        this.polar.series = [\n          {\n            name: legend ? legend[0] : text,\n            type: 'bar',\n            barMaxWidth: 25,\n            data: yAxis,\n            label: {\n              show: showLabel,\n              position: labelPosition,\n              color: labelColor,\n              fontSize: labelFontSize\n            },\n            itemStyle: {\n              // 渐变\n              normal: {\n                color: new echarts.graphic.LinearGradient(0, 1, 0, 0, [\n                  {\n                    offset: 0,\n                    color: color0\n                  },\n                  {\n                    offset: 1,\n                    color: color1\n                  }\n                ]),\n                barBorderRadius: 4\n              }\n            }\n          }\n        ]\n      }\n      // 开启缩放\n      if (isZoom) {\n        this.polar.dataZoom = [\n          {\n            type: 'inside',\n            show: true,\n            xAxisIndex: [0],\n            start: 1,\n            end: 35\n          }\n        ]\n      }\n      // 开启反转\n      if (reverse) {\n        ;[this.polar.xAxis, this.polar.yAxis] = [this.polar.yAxis, this.polar.xAxis]\n        this.polar.yAxis[0].data = [...xAxis].reverse()\n        this.polar.series = [\n          {\n            name: legend ? legend[0] : text,\n            type: 'bar',\n            barMaxWidth: 25,\n            data: [...yAxis].reverse(),\n            id: this.$utils.checkParam(id, null),\n            label: {\n              show: showLabel,\n              position: labelPosition,\n              color: labelColor,\n              fontSize: labelFontSize\n            },\n            itemStyle: isGradient\n              ? {\n                  normal: {\n                    color(params) {\n                      let index = color\n                        ? params.dataIndex % color.length\n                        : params.dataIndex % that.baseColors.length\n                      return new echarts.graphic.LinearGradient(1, 0, 0, 0, [\n                        {\n                          offset: 0,\n                          color: color ? color[index][0] : that.baseColors[index][0]\n                        },\n                        {\n                          offset: 1,\n                          color: color ? color[index][1] : that.baseColors[index][1]\n                        }\n                      ])\n                    },\n                    barBorderRadius: 40\n                  }\n                }\n              : {\n                  normal: {\n                    color(params) {\n                      let index = color\n                        ? params.dataIndex % color.length\n                        : params.dataIndex % that.baseColors.length\n                      return new echarts.graphic.LinearGradient(1, 0, 0, 0, [\n                        {\n                          offset: 0,\n                          color: color ? color[index] : that.baseColor[index]\n                        },\n                        {\n                          offset: 1,\n                          color: color ? color[index] : that.baseColor[index]\n                        }\n                      ])\n                    },\n                    barBorderRadius: 40\n                  }\n                }\n          }\n        ]\n        // 开启缩放\n        if (isZoom) {\n          this.polar.dataZoom = [\n            {\n              type: 'inside',\n              show: true,\n              yAxisIndex: [0],\n              start: 1,\n              end: 35\n            }\n          ]\n        }\n      }\n    },\n    handleBarClick(event) {\n      this.$emit('item-click', event, this.options.xAxis)\n    }\n  },\n  mounted() {\n    this.renderChart()\n  }\n}\n</script>\n"]}]}